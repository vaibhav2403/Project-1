<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Backtracking</title>
</head>
<body>
    <h2>Backtracking</h2>
    <p style=" size: 18px; color: #858585;">Backtracking is a form of recursion.</p> 
       <p style=" size: 18px; color: #858585;"> The usual scenario is that you are faced with a number of options, and you must choose one of these. After you make</p>
      
    <p style=" size: 18px; color: #858585;">your choice you will get a new set of options; just what set of options you get depends on what choice you made. This procedure is </p>
       <p style=" size: 18px; color: #858585;">repeated over and over until you reach a final state. If you made a good sequence of choices, your final state is a goal state; i</p>
         <p style=" size: 18px; color: #858585;">you didn't, it isn'</p>
        <br>
    <p style=" size: 18px; color: #858585;">Conceptually, you start at the root of a tree; the tree probably has some good leaves and some bad leaves, though it may be that</p> 
    <p style=" size: 18px; color: #858585;">the leaves are all good or all bad. You want to get to a good leaf. At each node, beginning with the root, you choose one of its </p>
    <p style=" size: 18px; color: #858585;">children to move to, and you keep this up until you get to a leaf. </p>
    <br>
    <p style=" size: 18px; color: #858585;">>Suppose you get to a bad leaf. You can backtrack to continue the search for a good leaf by revoking your most recent choice,</p> 
    <p style=" size: 18px; color: #858585;">and trying out the next option in that set of options. If you run out of options, revoke the choice that got you here, and try </p> 
    <p style=" size: 18px; color: #858585;">another choice at that node. If you end up at the root with no options left, there are no good leaves to be found.</p>
    <br>
    <p style=" size: 18px; color: #858585;">This needs an example.</p>
    <img src="./Image_root.png" alt="">
    <br>
    <p ><ol type="1" style=" size: 18px; color: #858585;" ><li>Starting at Root, your options are A and B. You choose A.</li>
        
    <li style=" size: 18px; color: #858585;">At A, your options are C and D. You choose C.</li>
    
    <li style=" size: 18px; color: #858585;">C is bad. Go back to A.</li>
    
    <li style=" size: 18px; color: #858585;">At A, you have already tried C, and it failed. Try D.</li>
    
    <li style=" size: 18px; color: #858585;">D is bad. Go back to A.</li>
    
    <li style=" size: 18px; color: #858585;">At A, you have no options left to try. Go back to Root.</li>
    
    <li style=" size: 18px; color: #858585;">At Root, you have already tried A. Try B.</li>
    
    <li style=" size: 18px; color: #858585;">At B, your options are E and F. Try E.</li>
    
    <li style=" size: 18px; color: #858585;">E is good. Congratulations!</li> </ol> 
     </p> <br>
     <div style="border: 1px solid  #D8D8D8;"><P style=" size: 18px; color: #858585;">In this example we drew a picture of a tree. The tree is an abstract model of the possible sequences of choices we could </p>
    <p style=" size: 18px; color: #858585;">make. There is also a data structure called a tree, but usually we don't have a data structure to tell us what choices we</p>
    <p style=" size: 18px; color: #858585;">have. (If we do have an actual tree data structure, backtracking on it is called depth-first tree searching.)</p> </div>
                       <h3>The backtracking algorithm.</h3>
     <br>
     <div style="border: 1px solid #D8D8D8;">
<pre style="color:#007EB4;"> 
    boolean solve(Node n) { 
     if n is a leaf node { 
             if the leaf is a goal node, return true  
             else return false 
          } else { 
             for each child c of n {  
               if solve(c) succeeds, return true   
             }  
            return false  
          }  
      }  </pre> </div>
                    <br>
                    <div style="border: 1px solid  #D8D8D8;"><P style=" size: 18px; color: #858585;">Notice that the algorithm is expressed as a boolean function. This is essential to understanding the algorithm. If </p>
                    <p style=" size: 18px; color: #858585;">solve(n) is true, that means node n is part of a solution--that is, node n is one of the nodes on a path from the root to </p>
                    <p style=" size: 18px; color: #858585;">some goal node. We say that n is solvable. If solve(n) is false, then there is no path that includes n to any goal node.</p>
                </div>
                    <br>
    <h7>How does this work?</h7>
    <ul type="Disc">
<pre><li style=" size: 18px; color: #858585;">If any child of n is solvable, then n is solvable.</li>
    <li style=" size: 18px; color: #858585;">If no child of n is solvable, then n is not solvable.</li>
    </ul></pre>
    <br>
    <p style=" size: 18px; color: #858585;">Hence, to decide whether any non-leaf node n is solvable (part of a path to a goal node), all you have to do is test whether any </p>
    <p style=" size: 18px; color: #858585;">child of n is solvable. This is done recursively, on each child of n. In the above code, this is done by the lines</p>
    <br>
    <div style="border: 1px solid #D8D8D8;">
        <pre style="color:#007EB4;"> for each child c of n { 
       if solve(c) succeeds, return true </P>
    } 
    return false </pre> </div>
    <br>
    <p style=" size: 18px; color: #858585;">Eventually the recursion will "bottom" out at a leaf node. If the leaf node is a goal node, it is solvable; if the leaf node is not a goal</p> 
   <P style=" size: 18px; color: #858585;"> it is not solvable. This is our base case. In the above code, this is done by the lines </P>
    <br>
    <div style="border: 1px solid #D8D8D8;">
        <pre style="color:#007EB4;">if n is a leaf node { 
            if the leaf is a goal node, return true 
            else return false 
        } </pre> </div>


    <p style=" size: 18px; color: #858585;">The backtracking algorithm is simple but important. You should understand it thoroughly. Another way of stating it is as follows:</p>
    <br>
    <li>To search a tree:</li>
    <ol>
        <li style=" size: 18px; color: #858585;">If the tree consists of a single leaf, test whether it is a goal node.</li>
        <li style=" size: 18px; color: #858585;"><p>search the subtrees until you find one containing a goal node, or until you have </p> 
            <P style=" size: 18px; color: #858585;">searched them all unsuccessfully. </P> </li>
    </ol>
    <br>
    <b size="22px">Non-recursive backtracking, using a stack</b>
    <p style=" size: 18px; color: #858585;">Backtracking is a rather typical recursive algorithm, and any recursive algorithm can be rewritten as a stack algorithm. In fact,</p> 
    <p style=" size: 18px; color: #858585;">that is how your recursive algorithms are translated into machine or assembly language.</p>
    <div style="border: 1px solid #D8D8D8;"><pre style="color: #007EB4;">
        boolean solve(Node n) {
          node n on the stack; 
         the stack is not empty { 
            if the node at the top of the stack is a leaf { 
                if it is a goal node, return true 
                else pop it off the stack 
             }   
               else {
                 if the node at the top of the stack has untried children 
                 the next untried child onto the stack 
                else pop the node off the stack 
            } 
               return false 
           } </pre> </div> 
           <br>
           <P style=" size: 18px; color: #858585;">Starting from the root, the only nodes that can be pushed onto the stack are the children of the node currently on the top of the </P>
           <P style=" size: 18px; color: #858585;">stack, and these are only pushed on one child at a time; hence, the nodes on the stack at all times describe a valid path in the </P>
           <P style=" size: 18px; color: #858585;">tree. Nodes are removed from the stack only when it is known that they have no goal nodes among their descendents. Therefore,</P>
           <P style=" size: 18px; color: #858585;">if the root node gets removed (making the stack empty), there must have been no goal nodes at all, and no solution to the </P>
           <P style=" size: 18px; color: #858585;">problem. </P>
           <P style=" size: 18px; color: #858585;">When the stack algorithm terminates successfully, the nodes on the stack form (in reverse order) a path from the root to a goal </P>
            <p style=" size: 18px; color: #858585;">node. </p>
             <p style=" size: 18px; color: #858585;">when the recursive algorithm finds a goal node, the path information is embodied (in reverse order) in the sequence of </p> 
             <p style=" size: 18px; color: #858585;">recursive calls. Thus as the recursion unwinds, the path can be recovered one node at a time, by (for instance) printing the node </p>
             <p style=" size: 18px; color: #858585;">at the current level, or storing it in an array.</p>
             <p style=" size: 18px; color: #858585;">Here is the recursive backtracking algorithm, modified slightly to print (in reverse order) the nodes along the successful path:</p>
             <br>
             <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;">
                boolean solve(Node n) { 
                    if n is a leaf node { 
            if the leaf is a goal node { 
             print n 
            return true 
             }
             else return false 
             } else {
             for each child c of n {  
             if solve(c) succeeds { 
             print n 
            return true 
             }
             }
             return false 
             } 
             }</pre></div>
             <br>
             <h5>Keeping backtracking simple</h5>
             <br>
             <p style=" size: 18px; color: #858585;">All of these versions of the backtracking algorithm are pretty simple, but when applied to a real problem, they can get pretty
             <p style=" size: 18px; color: #858585;">cluttered up with details. Even determining whether the node is a leaf can be complex: 
             <p style=" size: 18px; color: #858585;">for example, if the path represents a series of moves in a chess endgame problem, the leaves are the checkmate and stalemate 
             <p style=" size: 18px; color: #858585;">solutions 
             <p style=" size: 18px; color: #858585;">To keep the program clean, therefore, tests like this should be buried in methods. In a chess game, for example, you could test
             <p style=" size: 18px; color: #858585;"> whether a node is a leaf by writing a <b style="color: #424242;"> gameOver method </b> (or you could even call it <b style="color: #424242;">isLeaf).</b> This method would encapsulate all the 
             <p style=" size: 18px; color: #858585;"> ugly details of figuring out whether any possible moves remain. 
             <p style=" size: 18px; color: #858585;"> Notice that the backtracking altorithms require us to keep track, for each node on the current path, which of its children have 
             <p style=" size: 18px; color: #858585;"> been tried already (so we don't have to try them again). In the above code we made this look simple, by just saying  <b style="color: #424242;">for each child </b> </p> 
             <p style=" size: 18px; color: #858585;"><b style="color: #424242;">c of n.</b> In reality, it may be difficult to figure out what the possible children are, and there may be no obvious way to step through </p>
             <p style=" size: 18px; color: #858585;"> them. In chess, for example, a node can represent one arrangement of pieces on a chessboard, and each child of that node can </p>
             <p style=" size: 18px; color: #858585;"> represent the arrangement after some piece has made a legal move. How do you find these children, and how do you keep track </p>
             <p style=" size: 18px; color: #858585;"> of which ones you've already examined? </p>
             <p style=" size: 18px; color: #858585;"> The most straightforward way to keep track of which children of the node have been tried is as follows: Upon initial entry to the </p> 
             <p style=" size: 18px; color: #858585;"> node (that is, when you first get there from above), make a list of all its children. As you try each child, take it off the list. When </p> 
             <p style=" size: 18px; color: #858585;"> the list is empty, there are no remaining untried children, and you can return "failure." This is a simple approach, but it may require </p>
             <p style=" size: 18px; color: #858585;"> quite a lot of additional work. </p>
             <p style=" size: 18px; color: #858585;"> There is an easier way to keep track of which children have been tried, if you can define an ordering on the children. If there is an </p>
             <p style=" size: 18px; color: #858585;"> ordering, and you know which child you just tried, you can determine which child to try next.</p> 
             <p style=" size: 18px; color: #858585;"> For example, you might be able to number the <b style="color: #424242;">children 1 through n,</b> and try them in numerical order. Then, if you have just tried </p>
             <p style=" size: 18px; color: #858585;"> <b style="color: #424242;">child k,</b> you know that you have already tried children 1 through <b style="color: #424242;">k-1,</b> and you have not yet tried children <b style="color: #424242;">k+1</b> through <b style="color: #424242;">n.</b> Or, if you </p>
             <p style=" size: 18px; color: #858585;"> are trying to color a map with just four colors, you can always try  <b style="color: #424242;">red first, then yellow, then green, then blue.</b> If child yellow fails,</p>
             <p style=" size: 18px; color: #858585;">  you know to try child green next. If you are searching a maze, you can try choices in the order left, straight, right <b style="color: #424242;">(or perhaps</b> </p>
             <p style=" size: 18px; color: #858585;">  <b style="color: #424242;">north, east, south, west).</b> </p>
             <p style=" size: 18px; color: #858585;">  It isn't always easy to find a simple way to order the children of a node.<b style="color: #424242;">In the chess game example,</b> you might number your </p> 
             <p style=" size: 18px; color: #858585;">  pieces (or perhaps the squares of the board) and try them in numerical order; but in addition each piece may also have several </p>
             <p style=" size: 18px; color: #858585;">  moves, and these must also be ordered. </p>
             <p style=" size: 18px; color: #858585;">  You can probably find some way to order the children of a node. If the ordering scheme is simple enough, you should use it; but if it is too cumbersome, you are better off keeping a list of untried children.</p>
                <br>
                <b>Example: Tree Search</b>
               <p style=" size: 18px; color: #858585;"> For starters, let's do the simplest possible example of backtracking, which is searching an actual tree. We will also use the</p> 
                <p style=" size: 18px; color: #858585;">simplest kind of tree, a binary tree.</p>
                
                    <p style=" size: 18px; color: #858585;">A binary tree is a data structure composed of nodes. One node is designated as the root node. Each node can reference (point </p> 
                        <p style=" size: 18px; color: #858585;">to) zero, one, or two other nodes, which are called its children. The children are referred to as the left child and/or the right child. </p>
                            <p style=" size: 18px; color: #858585;">All nodes are reachable (by one or more steps) from the root node, and there are no cycles. For our purposes, although this is not </p>
                                <p style=" size: 18px; color: #858585;">part of the definition of a binary tree, we will say that a node might or might not be a goal node, and will contain its name. The </p> 
                                    <p style=" size: 18px; color: #858585;">first example in this paper (which we repeat here) shows a binary tree. </p> 
                
                                        <p style=" size: 18px; color: #858585;">Here's a definition of the BinaryTree class: </p>
                <br>
                <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;">
                 public class BinaryTree { 
                    BinaryTree leftChild = null; 
                    BinaryTree rightChild = null; boolean isGoalNode = false;
                     String name; BinaryTree(String name, 
                     
                     BinaryTree left, BinaryTree right, boolean isGoalNode) { 
                        this.name = name; 
                        eftChild = left; 
                        rightChild = right; 
                        this.isGoalNode = isGoalNode; 
                    } 
                }
            </pre></div>
             <P style=" size: 18px; color: #858585;">Next we will create a TreeSearch class, and in it we will define a method makeTree() which constructs the above binary tree</P>
            
                <b>What are the children? </b>
                <br>

                <P style=" size: 18px; color: #858585;"> One of the things that simplifies the above binary tree search is that, at each choice point, you can ignore all the previous</P> 
                    <P style=" size: 18px; color: #858585;">choices. Previous choices don't give you any information about what you should do next; as far as you know, both the left and the </P>
                        <P style=" size: 18px; color: #858585;"> right child are possible solutions. In many problems, however, you may be able to eliminate children immediately, without </P>
                            <P style=" size: 18px; color: #858585;">recursion. </P>
             
                                <P style=" size: 18px; color: #858585;">Consider, for example, the problem of four-coloring a map. It is a theorem of mathematics that any map on a plane, no matter </P> 
                                    <P style=" size: 18px; color: #858585;"> how convoluted the countries are, can be colored with at most four colors, so that no two countries that share a border are the </P> 
                                        <P style=" size: 18px; color: #858585;">same color. </P>
             
                                            <P style=" size: 18px; color: #858585;">To color a map, you choose a color for the first country, then a color for the second country, and so on, until all countries are </P>
                                                <P style=" size: 18px; color: #858585;">colored.</P> 
             
                                                    <P style=" size: 18px; color: #858585;">There are two ways to do this: </P>

                                                        <P style=" size: 18px; color: #858585;">Method 1. Try each of the four possible colors, and recur. When you run out of countries, check whether you are at a goal node </P>

                                                            <P style=" size: 18px; color: #858585;">Method 2. Try only those colors that have not already been used for an adjacent country, and recur. If and when you run out of </P>
                                                                <P style=" size: 18px; color: #858585;">countries, you have successfully colored the map. </P>

                                                                    <P style=" size: 18px; color: #858585;">Let's apply each of these two methods to the problem of coloring a checkerboard. This should be easily solvable; after all, a </P>
                                                                        <P style=" size: 18px; color: #858585;"> checkerboard only needs two colors.</P>

             <b style="color: #424242;">boolean mapIsOK() </b>
             <P style=" size: 18px; color: #858585;">Used by method 1 to check (at a leaf node) whether the entire map is colored correctly.</P> 
             <b style="color: #424242;">boolean okToColor(int row, int column, int color) </b>
             <P style=" size: 18px; color: #858585;"> Used by method 2 to check, at every node, whether there is an adjacent node already colored with the given color. </P>
             <b style="color: #424242;">int[] nextRowAndColumn(int row, int column) </b>
             <P style=" size: 18px; color: #858585;">Used by both methods to find the next "country" (actually, the row and column of the next square on the checkerboard).</P>

             <P style=" size: 18px; color: #858585;">Here's the code for method 1:</P>

             <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;"> boolean explore1(int row, int column, int color) { 
                if (row >= NUM_ROWS)return mapIsOK(); 
                map[row][column] = color; 
                for (int nextColor = RED; nextColor <= BLUE; nextColor++) { 
                    int[] next = nextRowAndColumn(row, column); 
                    if (explore1(next[0], next[1], nextColor)) return true; 
                } 
                return false; 
            } </div> </pre>
            <br>

            <P style=" size: 18px; color: #858585;"> And here's the code for method 2:</P>

            <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;">
                boolean explore2(int row, int column, int color)  { 
                if (row >= NUM_ROWS)return true; 
                if (okToColor(row, column, color)) { 
                    map[row][column] = color; 
                    for (int nextColor = RED; nextColor <= BLUE; nextColor++) { 
                        int[] next = nextRowAndColumn(row, column); 
                        if (explore2(next[0], next[1], nextColor)) return true; 
                    } 
                } 
                return false; 
            } 
             </div></pre>
            <br>
            

            <p style=" size: 18px; color: #858585;">Those appear pretty similar, and you might think they are equally good. However, the timing information suggests otherwise: </p>
            
            <tr>
                <center>
                   <table table border="1" width="548px" higth="139px"  cellpadding="10"cellspacling="0">
                   <td bgcolor="white"></td>
                   <th bgcolor="grey">2 by 3 map</th>
                   <th bgcolor="grey">3 by 3 map</th>
                   <th bgcolor="white">3 by 4 map</th>
               </tr>    
                    <tr>
                       <th bgcolor="grey">method 1:</th>
                       <td bgcolor="grey">60 ms.</td>
                       <td bgcolor="white">940 ms.</td>
                       <td bgcolor="grey">60530 ms. (1 minute</td>
                     </tr>
                     <tr>
                        <th bgcolor="grey">method 2:</th>
                        <td>0ms.</td>
                        <td>0 ms.</td>
                        <td>0 ms</td>
                     </tr>
                    </table> 
                   </center>
                   <br>
                   <p style=" size: 18px; color: #858585;">The zeros in the above table indicate times too short to measure (less than 1 millisecond). Why this huge difference? Either of </p>
                   <p style=" size: 18px; color: #858585;"> these methods could have exponential growth. Eliminating a node automatically eliminates all of its descendents, and this will </p>
                    <p style=" size: 18px; color: #858585;"> often prevent exponential growth. Conversely, by waiting to check until a leaf node is reached, exponential growth is practically </p>
                    <p style=" size: 18px; color: #858585;">guaranteed. If there is any way to eliminate children (reduce the set of choices), do so!</p>
                   <hr>
                   <b>Debugging techniques</b>
                   <p style=" size: 18px; color: #858585;"> Often our first try at a program doesn't work, and we need to debug it. Debuggers are helpful, but sometimes we need to fall </p>
                    <p style=" size: 18px; color: #858585;"> back on inserting print statements. There are some simple tricks to making effective use of print statements. These tricks can be </p> 
                        <p style=" size: 18px; color: #858585;">applied to any program, but are especially useful when you are trying to debug recursive routines. </p>
                   <br>
                   <b>Trick #1: Indent when you print method entries and exits.</b>
                   <p style=" size: 18px; color: #858585;">Often, the best debugging technique is to print every method call and return (or at least the most important ones). You probably </p>
                   <p style=" size: 18px; color: #858585;"> want to print, for each method, what parameters it came in with, and what value it leaves with. However, if you just print a long </p> 
                    <p style=" size: 18px; color: #858585;">list of these, it's hard to match up method exits with their corresponding entries. Indenting to show the level of nesting can help.</p>
                   <br>
                   <b>Trick #2: Use specialized print methods for debugging.</b>
                   <p style=" size: 18px; color: #858585;">Don't clutter up your actual code more than you must. Also, remember that code inserted for debugging purposes can itself </p> 
                   <p style="color: #858585;"> contain bugs, or (in the worst case) can affect the results, so be very careful with it.</p>
                    <br>
                    <p style=" size: 18px; color: #858585;"> Here's our debugging code. For this trivial program, there's almost more debugging code than actual code, but in larger programs </p>
                   <p style=" size: 18px; color: #858585;"> the proportions will be better.</p>
                    <br>
                    <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;">
                        static String indent = "";
                         
                        static String name(BinaryTree node) { 
                            if (node == null) return null; 
                            else return node.name; 
                        } 
                        
                        static void enter(BinaryTree node) { 
                            System.out.println(indent + "Entering solvable(" + name(node) + ")"); 
                            indent = indent + "| "; 
                        } 
                        
                        static boolean yes(BinaryTree node) { 
                            indent = indent.substring(3); 
                            System.out.println(indent + "solvable(" + name(node) + ") returns true"); 
                            return true; 
                        } 
                        
                        static boolean no(BinaryTree node) { 
                            indent = indent.substring(3); 
                            System.out.println(indent + "solvable(" + name(node) + ") returns false"); 
                            return false; 
                        }
                    </pre> </div>
                    <br>
                    <p style=" size: 18px; color: #858585;">To use this code, we modify solvable as follows:</p>
                    <br>
                    <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;">
                        static boolean solvable(BinaryTree node) { 
                            enter(node); 
                            if (node == null) return no(node); 
                            if (node.isGoalNode) return yes(node); 
                            if (solvable(node.leftChild)) return yes(node); 
                            if (solvable(node.rightChild)) return yes(node); 
                            return no(node); 
                        }
                    </pre> </div>
                    <pre style=" size: 18px; color: #858585;" >And we get these results:
                    Entering solvable(Root) 
                    | Entering solvable(A) 
                    | | Entering solvable(C) 
                    | | | Entering solvable(null) 
                    | | | solvable(null) returns false 
                     | | Entering solvable(null) 
                     | | | solvable(null) returns false 
                     | | solvable(C) returns false 
                     | | Entering solvable(D) 
                     | | | Entering solvable(null) 
                     | | | solvable(null) returns false 
                     | | | Entering solvable(null) 
                     | | | solvable(null) returns false 
                     | | solvable(D) returns false 
                     | solvable(A) returns false 
                      Entering solvable(B) 
                      | | Entering solvable(E) 
                      | | solvable(E) returns true 
                        | solvable(B) returns true 
                        solvable(Root) returns true 
                        true 
                    </pre>
                    <br>
                    <b>Trick #3: Never discard your debugging statements.</b>
                        <p style=" size: 18px; color: #858585;"> Writing debugging statements is programming, too. Often it's as much work to debug </p>
                            <p style=" size: 18px; color: #858585;">the debugging statements as it is to debug the actual program. Once your program is working, why throw this code away? </p>
                    
                                <p style=" size: 18px; color: #858585;">Obviously, you don't want to print out all this debugging information from a program you are ready to submit (or to turn over to </p>
                                    <p style=" size: 18px; color: #858585;">your manager). You could comment out your debugging calls, but that can be a lot of work. What's more, in the above example, </p>
                                        <p style=" size: 18px; color: #858585;">you would have to replace every return(yes(node)) with return(true), and every return(no(node)) with return false. With all these </p>
                                            <p style=" size: 18px; color: #858585;">changes, you might introduce new bugs into your program. </p>
                    
                                                <p style=" size: 18px; color: #858585;">The simple solution is to make your debugging statements conditional. For example, </p>
                    <br>
                    <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;">
                        static final boolean debugging = false; 
                        
                        static void enter(BinaryTree node) { 
                            if (debugging) { 
                                System.out.println(indent + "Entering solvable(" + name(node) + ")"); 
                                indent = indent + "| ";
                             } 
                            } 
                            
                            static boolean yes(BinaryTree node) { 
                                if (debugging) { 
                                    indent = indent.substring(3); 
                                    System.out.println(indent + "solvable(" + name(node) + ") returns true"); 
                                } 
                                return true; 
                            } 
                            
                            static boolean no(BinaryTree node) { 
                                if (debugging) { 
                                    indent = indent.substring(3); 
                                    System.out.println(indent + "solvable(" + name(node) + ") returns false"); 
                                } 
                                return false; 
                            }
                        </pre> </div>
                        <br>
                        <p style=" size: 18px; color: #858585;">In industry, actual programs often have multiple flags to control different aspects of debugging. Don't worry too much about </p>
                           <p style=" size: 18px; color: #858585;"> making your code larger; modern compilers will notice that since the variable debugging is final, it can never be true, and the </p>
                           <p style=" size: 18px; color: #858585;"> controlled code will be discarded.</p>
                            <br>
                           <b>Trick #4: Create an Exception.</b>
                           <P style=" size: 18px; color: #858585;">If an Exception is thrown, you can get information about just where it happened by sending it the message </P>
                            <P style=" size: 18px; color: #858585;"> printStackTrace(PrintStream). Since an Exception is an object like any other, you can create and throw your own Exceptions. </P>
                            <P style=" size: 18px; color: #858585;">  However, Java programmers don't always realize that you can create an Exception without throwing it. For example, the following </P> 
                                <P =" size: 18px; color: #858585;">  code </P>
                        </Pre>
                        <br>
                        <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;">
                            new Exception("Checkpoint Charlie").printStackTrace(System.out);</pre></div>
                            <br>
                            <p style=" size: 18px; color: #858585;">will print out a message something like this, and the program will then continue normally. That is, the above code just acts like a  </p>
                                <P style=" size: 18px; color: #858585;">style print statement.</p>
                                <br>
                                <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;"size="18px">
                                    java.lang.Exception: Checkpoint Charlie 
                                    at TreeSearch.solvable(TreeSearch.java:53) 
                                    at TreeSearch.solvable(TreeSearch.java:57)
                                     at TreeSearch.main(TreeSearch.java:72) 
                                     at __SHELL38.run(__SHELL38.java:16) 
                                     at bluej.runtime.ExecServer.suspendExecution(Unknown Source)</pre> </div>
                                     <br>
                                     <hr>
                                     <b>Example: Cindy's Puzzle </b>
                                     <p style=" size: 18px; color: #858585;">I call the following puzzle "Cindy's puzzle" for historical reasons. You have some number n of black marbles and the same number </p>
                                    <p style=" size: 18px; color: #858585;">of white marbles, and you have a playing board which consists simply of a line of 2n+1 spaces to put the marbles in. Start with  </p>
                                     <p style=" size: 18px; color: #858585;">the black marbles all at one end (say, the left), the white marbles all at the other end, and a free space in between.</p>
                                     <br>
                                    <center><table table border="1px" bgcolor="lightgrey">
                                        <tr><td><img src="./black-ball.png"></td>
                                        <td><img src="./black-ball.png"></td>
                                        <td width="50px"></td>
                                        <td><img src="./white-ball.png"></td>
                                        <td><img src="./white-ball.png"></td>
                                    </tr>
                                    </table></center>
                                    <br>
                                    <p style=" size: 18px; color: #858585;">The goal is to reverse the positions of the marbles:</p>
                                    <br>
                                    <center><table table border="1px"bgcolor="lightgrey"> 
                                        <tr>
                                        <td><img src="./white-ball.png"></td>
                                        <td><img src="./white-ball.png"></td>
                                        <td width="50px"></td>
                                        <td><img src="./black-ball.png"></td>
                                        <td><img src="./black-ball.png "></td>
                                    </tr>
                                    </table></center>
                                    <br>
                                    <p style=" size: 18px; color: #858585;">The black marbles can only move to the right, and the white marbles can only move to the left (no backing up). At each move, a </p> 
                                    <p style=" size: 18px; color: #858585;">marble can either:</p> 
                                    <br>
                                    <ul type="disc"><li style=" size: 18px; color: #858585;">one space ahead, if that space is clear, or</li>
                                    <li style=" size: 18px; color: #858585;">Jump ahead over exactly one marble of the opposite color, if the space just beyond that marble is clear.</li>
                                </ul>
                                <br>
                                <p style=" size: 18px; color: #858585;">For example, you could make the following sequence of moves:</p>
                                <center>
                                    <table>
                                    <tr>
                                        <th>Starting Position:</th>
                                        <td>
                                            <table border="1px"bgcolor="lightgrey">
                                                <tr>
                                        <td><img src="./black-ball.png"></td>
                                        <td><img src="./black-ball.png"></td>
                                        <td width="50px"></td>
                                        <td><img src="./white-ball.png"></td>
                                        <td><img src="./white-ball.png"></td>
                                     </tr>
                                    </table>
                                </td>
                            </tr>
                                </table>
                                <table>
                                    <tr>
                                        <th>Black moves ahead:</th>
                                        <td>
                                            <table border="1px"bgcolor="lightgrey">
                                                <tr>
                                        <td><img src="./black-ball.png"></td>
                                        <td width="50px"></td>
                                        <td><img src="./black-ball.png"></td>
                                        <td><img src="./white-ball.png"></td>
                                        <td><img src="./white-ball.png"></td>
                                        </tr>
                                    </table>
                                </td>
                                    </tr>
                                 </table>
                                 <table>
                                    <tr>
                                        <th>white jumps:</th>
                                        <td>
                                            <table border="1px"bgcolor="lightgrey">
                                                <tr>
                                        <td><img src="./black-ball.png"></td>
                                        <td><img src="./white-ball.png"></td>
                                        <td><img src="./black-ball.png"></td>
                                        <td width="50px"></td>
                                        <td><img src="./white-ball.png"></td>
                                        </tr>
                                    </table>
                                </td>
                                    </tr>
                                 </table>
                                 <table>
                                    <tr>
                                        <th>Black moves ahead:</th>
                                        <td>
                                            <table border="1px"bgcolor="lightgrey">
                                                <tr>
                                        <td><img src="./black-ball.png"></td>
                                        <td><img src="./white-ball.png"></td>
                                         <td width="50px"></td>
                                        <td><img src="./black-ball.png"></td>
                                        <td><img src="./white-ball.png"></td>
                                        </tr>
                                    </table>
                                </td>
                                    </tr>
                                 </table>
                                 <table>
                                 <tr>
                                    <th>Black jumps:</th>
                                    <td>
                                        <table border="1px"bgcolor="lightgrey">
                                     <tr>
                                    <td width="50px"></td>
                                    <td><img src="./white-ball.png"></td>
                                    <td><img src="./black-ball.png"></td>
                                    <td><img src="./black-ball.png"></td>
                                    <td><img src="./white-ball.png"></td>
                                    </tr>
                                </table>
                            </td>
                                </tr>
                             </table>
                             <table>
                                <tr>
                                    <th> white moves ahead:</th>
                                    <td>
                                    <table border="1px"bgcolor="lightgrey">
                                    <tr>
                                    <td width="50px"></td>
                                    <td><img src="./white-ball.png"></td>            
                                    <td><img src="./black-ball.png"></td>
                                    <td><img src="./black-ball.png"></td>
                                    <td><img src="./white-ball.png"></td>
                                    </tr>
                                </table>
                            </td>
                                </tr>
                             </table>
                             <table>
                                <tr>
                                <th>Stuck</th>
                             </tr>
                            </table>
                             </center>
                             <br>
                             <p style=" size: 18px; color: #858585;">The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a leaf,</p> 
                             <P style=" size: 18px; color: #858585;">which in this case means a position from which no further moves are possible. This isn't so easy.</P> 
                             
                             <P style=" size: 18px; color: #858585;">Now to the program. The main program will initialize the board, and call a recursive backtracking routine to attempt to solve the </P> 
                             <P style=" size: 18px; color: #858585;">puzzle. The backtracking routine will either succeed and print out a winning path, or it will fail, and the main program will have to </P>

                             <P style=" size: 18px; color: #858585;">print out the bad news. </P>

                            
                             <P style=" size: 18px; color: #858585;">The backtracking method is named solvable and returns a boolean. In solvable we shall need to check whether we are at a leaf,</P>
                             <P style=" size: 18px; color: #858585;">which in this case means a position from which no further moves are possible. This isn't so easy.</P> 
                             
                             <P style=" size: 18px; color: #858585;">Each possible move will result in a new board position, and these new board positions are the children of the current board</P> 
                             <P style=" size: 18px; color: #858585;">position. Hence to find the children of a node (that is, of a board position), we need only find the possible moves from that node. </P>
                             <P style=" size: 18px; color: #858585;">Remember that it is also highly desirable to find an ordering on these possible moves. </P>
                             
                             <P style=" size: 18px; color: #858585;">Here it is time to stop and take thought. To make progress, we must analyze the game to some extent. Probably a number of </P>
                             <P style=" size: 18px; color: #858585;">approaches would work, and what follows is based on the way I worked it out. If you were to program this puzzle, you might find </P>
                             <P style=" size: 18px; color: #858585;">a different but equally valid approach. </P>
                             
                             <P style=" size: 18px; color: #858585;">First, notice that if a marble has a move, that move is unique: if it can move ahead one square, then it cannot jump. If it can jump, </P>

                             <P style=" size: 18px; color: #858585;">it cannot move ahead one square. This suggests that, to find the possible moves, we might assign numbers to the marbles, and </P>
                             <P style=" size: 18px; color: #858585;" >check each marble in turn. When we have looked at all the marbles, we have looked at all the possible moves. This would require </P>
                             <P style=" size: 18px; color: #858585;">having a table to keep track of where each marble is, or else somehow "marking" each marble with its number and searching the </P>
                             <P style=" size: 18px; color: #858585;">board each time to find the marble we want. Neither alternative is very attractive. </P>
                             
                             <p style=" size: 18px; color: #858585;">Next, notice that for a given board position, each marble occupies a unique space. Hence, instead of talking about moving a </p>
                             <P style=" size: 18px; color: #858585;">particular marble, we can talk about moving the marble in a particular space. If a move is possible from a given space, then that </P> 
                             <P style=" size: 18px; color: #858585;">must be the only move possible from that space, because if the marble in that space has a move, it is unique. There is a slight </P>
                             <P style=" size: 18px; color: #858585;">omplication because not every space contains a marble, but at least the spaces (unlike the marbles) stay in one place.</p>
                             
                             <br>
                             <p style=" size: 18px; color: #424242;">Now we have a simpler ordering of moves to use in our program. Just check, in order, the 2n+1 spaces of the board. For each </p>
                             <p style=" size: 18px; color: #424242;">space, either zero or one moves is possible. With this understanding, we can write a boolean method canMove(int[] board, int </p>
                             <p style=" size: 18px; color: #424242;">position) which determines whether a move is possible from the given position: </p>
                             <br>
                             <ul type="disc">
                                <li style=" size: 18px; color: #858585;">If the position is empty, no move is possible;</li>
                                <li style=" size: 18px; color: #858585;" >If the position contains a black marble, the method checks for a move or jump to the right;</li>
                                <li style=" size: 18px; color: #858585;">If the position contains a white marble, the method checks for a move or jump to the left.</li>
                             </ul>
                             <br>
                             <P style=" size: 18px; color: #858585;">We write another method <b style="color: #424242;">int [] makeMove(int[] oldBoard, int position)</b> that will take a board and a position, make a move from </P>
                             <P style=" size: 18px; color: #858585;">We write another method int[] makeMove(int[] oldBoard, int position) that will take a board and a position, make a move from </P>
                             <p style=" size: 18px; color: #858585;">that position, and return as its value a new board. (We could write this somewhat more efficiently by changing the old board, </p>
                             <P style=" size: 18px; color: #858585;">rather than creating a new one, but here we are more concerned with simplicity.) In technical jargon, makeMove is "applicative" </P>
                             <p style=" size: 18px; color: #858585;"> rather than "mutative." </p>
                             
                             <p style=" size: 18px; color: #858585;">Along with <b style="color: #424242;">canMove and makeMove,</b> we are using methods <b style="color: #424242;>uzzleSolved and printBoard</b> p with meanings that </p> 
                             <p style=" size: 18px; color: #858585;">should be obvious.</p>  
                             <br>
                             <div style="border:1px solid #D8D8D8;"><pre style="color: #007EB4;">
                                boolean solvable(int[] board) { if (puzzleSolved(board)) { 
                                    return true; 
                                } 
                                    for (int position = 0; position < BOARD_SIZE; position++) { 
                                        if (canMove(board, position)) { 
                                            int[] newBoard = makeMove(board, position); 
                                            if (solvable(newBoard)) { 
                                                printBoard(newBoard); 
                                                return true; 
                                            } 
                                        } 
                                    } 
                                    return false; 
                                }
                            </pre> </div>
                            <br>
                            <p style=" size: 18px; color: #858585;">Along with canMove and makeMove, we are using methods puzzleSolved and printBoard with meanings that should be obvious. </p>
                            <p style=" size: 18px; color: #858585;"> Here is some output from the program:</p>
                            <br>
                            <ol start="16"reversed>
                                <b><li>WHITE WHITE WHITE _____ BLACK BLACK BLACK</li></b>
                                <b><li>WHITE WHITE WHITE BLACK _____ BLACK BLACK</li></b>
                                <b><li>WHITE WHITE _____ BLACK WHITE BLACK BLACK</li></b>
                                <b><li>WHITE _____ WHITE BLACK WHITE BLACK BLACK</li></b>
                                <b><li>WHITE BLACK WHITE _____ WHITE BLACK BLACK</li></b>
                                <b><li>WHITE BLACK WHITE BLACK WHITE _____ BLACK</li></b>
                                <b><li>WHITE BLACK WHITE WHITE BLACK BLACK _____</li></b> 
                                <b><li>WHITE BLACK WHITE BLACK _____BLACK WHITE</li></b>
                                <b><li>WHITE  BLACK _____ BLACK WHITE BLACK WHITE</li></b>
                                <b><li>_____ BLACK WHITE BLACK  WHITE BLACK WHITE</li></b>
                                <b><li>BLACK _____ WHITE BLACK WHITE BLACK WHITE</li></b> 
                                <b><li>BLACK BLACK WHITE _____ WHITE BLACK WHITE</li></b>
                                <b><li>BLACK BLACK WHITE BLACK WHITE _____ WHITE</li></b>
                                <b><li>BLACK BLACK WHITE BLACK _____ WHITE WHITE</li></b>
                                <b><li>BLACK BLACK _____ BLACK WHITE WHITE WHITE</li></b>
                                <b><li>BLACK BLACK BLACK _____ WHITE WHITE WHITE </li></b>
                            </ol> 
                            <br>
                            <div style="border: 1px solid  #D8D8D8;"><P style=" size: 18px; color: #858585;">Notice that the solution is given in reverse order: BLACK starts out on the left and WHITE on the right, as in the last </p>
                             <p style=" size: 18px; color: #858585;">line. I've added line numbers to the actual output in order to emphasize this point. Backtracking always produces its </p>
                             <p style=" size: 18px; color: #858585;">results (sequence of choices) in reverse order; it is up to you, the programmer, to reverse the results again to get </p>
                            <p style=" size: 18px; color: #858585;">them in the correct order.</P>
                            
                            
                             










                    


                    









    


    
</body>
</html>